/*****************************************************************************
 *
 * This file belongs to the Willert Software Tools RXF Product:  
 * 
 *
 * File Path	: ../Source/generic/RXF_EventQueue.cpp
 *
 * Copyright (C) Willert Software Tools GmbH.
 *
 *****************************************************************************/

#include "RXF_ErrorHandler.h"
#include "RXF_EventQueue.h"
namespace RXF {
    
    /* @MISRA_5-0-15=OFF FD-0001: The Memory, that is accessed via array indexing belongs to an array that is generated by the code generator and passed via the constructor. */
    
    
    EventQueue::EventQueue(Event** const queueMemory, const std::uint32_t queueSize) : queue(queueMemory), size(queueSize), count(0U), maxCount(0U), head(0U), tail(0U)
    {
        if ( nullptr != queue )
        {
        	for (std::uint32_t i = 0U; i < size; i++) 
        	{
        		queue[i] = nullptr;
        	}
        }
    }
    
    bool EventQueue::isEmpty(void) const
    {
        return 0U == count;
    }
    
    bool EventQueue::isFull(void) const
    {
        return size == count;
    }
    
    bool EventQueue::put(Event* const event)
    {
        const bool eventQueued = !isFull();
        
        if ( eventQueued )
        {
        	queue[tail] = event;
        	tail = ( tail + 1U ) % size;	
        	count++;
        	if( count > maxCount )
        	{
        		maxCount = count;
        	}
        }
        
        return eventQueued;
    }
    
    Event* EventQueue::get(void)
    {
        Event* event = nullptr; 
        
        if( !isEmpty() )
        {
        	event = queue[head];
        	queue[head] = nullptr;
        	head = ( head + 1U ) % size;
        	count--;
        	
        	while( ( queue[head] == nullptr ) &&  ( !isEmpty() ) )
        	{
        		head = ( head + 1U ) % size;
        		count--;
        	}
        }
        
        return event;
    }
    
    void EventQueue::cancelEvents(const Reactive* const destination)
    {
        std::uint32_t index = head;
        
        while( index != tail )
        {
        	RXF::Event* const event = queue[index];
        	if( ( nullptr != event ) && ( destination == event->getDestination() ) )
        	{
        		queue[index] = nullptr;
        		event->destroy();
        	}
        	index = ( index + 1U ) % size;
        }
        
        cleanUp();
    }
    
    void EventQueue::cancelTimeoutEvent(const TimeoutEvent* const timeoutEvent)
    {
        std::uint32_t index = head;
        
        while( index != tail )
        {
        	if( static_cast<const RXF::Event*>(timeoutEvent) == queue[index] )
        	{
        		queue[index] = nullptr;
        	}
        	index = ( index + 1U ) % size;
        }
        
        cleanUp();
    }
    
    void EventQueue::cleanUp(void)
    {
        while( ( queue[head] == nullptr ) &&  ( !isEmpty() ) )
        {
        	head = ( head + 1U ) % size;
        	count--;
        }
        
        while( ( queue[ ( tail - 1U ) % size ] == nullptr ) &&  ( !isEmpty() ) )
        {
        	tail = ( tail - 1U ) % size;
        	count--;
        }
    }
    
    
    /* @MISRA_5-0-15=ON (end of FD-0001) */
}

/*********************************************************************
	File Path	: ../Source/generic/RXF_EventQueue.cpp
*********************************************************************/
